alloc_arrays.F:      allocate(x2a    (jn))
alloc_arrays.F:      allocate(x2ai   (jn))
alloc_arrays.F:      allocate(dx2a   (jn))
alloc_arrays.F:      allocate(dx2ai  (jn))
alloc_arrays.F:       allocate(x2ah    (jn))
alloc_arrays.F:       allocate(dx2ah   (jn))
alloc_arrays.F:       allocate(x2an    (jn))
alloc_arrays.F:       allocate(dx2an   (jn))
alloc_arrays.F:       allocate(x2ahi   (jn))
alloc_arrays.F:       allocate(dx2ahi  (jn))
alloc_arrays.F:       allocate(x2ani   (jn))
alloc_arrays.F:       allocate(dx2ani  (jn))
avisc.F:           q3      = dvelas   * dx2ai(j) * g2bi(i)
avisc.F:           q3      = dvelbs   * dx2ai(j) * g2bi(i)
blast.F:C           b2(i,j,k) = -b30*dsin(x2a(j))
blast.F:     .                  ( g32a(j+1)*sin(x2a(j+1)) -
blast.F:     .                    g32a(j  )*sin(x2a(j  ))  )
blast.F:           b2(i,j,k) = -0.5*b30*g2b(i)*sin(x2a(j))*dvl1ai(i)*
blast.F:         if ( abs(x2a(j)-x20) .lt. abs(x2a(jp1)-x20) ) then
blast.F:     1            + ( x2a(jin (j)) - x20 )**2
blast.F:     1            + ( x2a(jout(j)) - x20 )**2
blast.F:     1            + ( x2a(jin (j)) - x20 )**2
blast.F:     1            + ( x2a(jout(j)) - x20 )**2
blast.F:             rsq  = r**2 * ( 1.0 + drs * sin (m * x2a(j))
blast.F:     1                           + drc * cos (m * x2a(j)) )**2
blast.F:     1                      , x1a(iin (i)), x2a(jin (j)), x3a(kin (k))
blast.F:     2                      , x1a(iout(i)), x2a(jout(j)), x3a(kout(k)) )
bondi.F:         a3(i,j) = 1e-6*x1a(i)*sin(x2a(j))
bondi.F:         b1(i,j,k) = (g32a(j+1)*a3(i,j+1)-g32a(j)*a3(i,j))/(x2a(j+1)-
bondi.F:     &    x2a(j))/g31a(i)/g32b(j)
cluster.F:c         a3(i,j) = prefac*x1a(i)*sin(x2a(j))/(6.0d23) !roughly rout=200 kpc
cluster.F:c         b1(i,j,k) = (g32a(j+1)*a3(i,j+1)-g32a(j)*a3(i,j))/(x2a(j+1)-
cluster.F:c     &    x2a(j))/g31a(i)/g32b(j)
crdiffuse_d.F:        dr2min = min(dx1a(i),g2b(i)*dx2a(j),g31b(i)*g32b(j)*dx3a(k))
crdiffuse.F:         decrx2 = decrx2*g2ai(i)*dx2ai(j)
crdiffuse.F:          if (x2a(j).le.1d-10.and.x2a(j).ge.-1d-10) decrx3 = 0.0d0
crdiffuse.F:          if (x2a(j).le.pi+1d-10.and.x2a(j).ge.pi-1d-10) decrx3 = 0.0d0
crdiffuse.F:         decrx2 = decrx2*g2bi(i)*dx2ai(j)
ct_1D.F:c      Coordinate-imposed boundary conditions (e.g., reflecting at x2a=0
ct_1D.F:         qty2  (j) = g32b  (j) * dx2a  (j)
ct_1D.F:         qty2ni(j) = g32bni(j) * dx2ani(j)
ct_1D.F:         qty2ni(j) = g32bi(j) * dx2ai(j)
ct_1D.F:          b3(i,j,k) = ( b3(i,j,k) * qty1(i) * dx2a(j)
ct_1D.F:     3              * qty1ni(i) * dx2ani(j)
ct_1D.F:          b3(i,j,k) = ( b3(i,j,k) * qty1(i) * dx2a(j)
ct_1D.F:     3              * qty1ni(i) * dx2ai(j)
ct_2D.F:c      Coordinate-imposed boundary conditions (e.g., reflecting at x2a=0
ct_2D.F:         qty2  (j) = g32b  (j) * dx2a  (j)
ct_2D.F:         qty2ni(j) = g32bni(j) * dx2ani(j)
ct_2D.F:         qty2ni(j) = g32bi(j) * dx2ai(j)
ct_2D.F:             b3(i,j,k) = ( b3(i,j,k) * qty1(i) * dx2a(j)
ct_2D.F:     3                 * qty1ni(i) * dx2ani(j)
ct_2D.F:             b3(i,j,k) = ( b3(i,j,k) * qty1(i) * dx2a(j)
ct_2D.F:     3                 * qty1ni(i) * dx2ai(j)
ct.F:c      Coordinate-imposed boundary conditions (e.g., reflecting at x2a=0
ct.F:         qty2  (j) = g32b  (j) * dx2a  (j)
ct.F:         qty2ni(j) = g32bni(j) * dx2ani(j)
ct.F:         qty2ni(j) = g32bi(j) * dx2ai(j)
ct.F:             b3(i,j,k) = ( b3(i,j,k) * qty1(i) * dx2a(j)
ct.F:     3                 * qty1ni(i) * dx2ani(j)
ct.F:             b3(i,j,k) = ( b3(i,j,k) * qty1(i) * dx2a(j)
ct.F:     3                 * qty1ni(i) * dx2ai(j)
diverg.F:     3                  / (dx1a(i) + g2b(i) * dx2a(j)   +
forces.F:           if(x2a(j) .ne. 0.0) then
forces.F:     1                  + ( x2a(j) - x2ptm )**2
forces.F:              r2i       = ( x2a(j) - x2ptm )
forces.F:     1                  + ( x2a(j) - x2ptm )**2
forces.F:     2                  + 2.0 * x2a(j) * x2ptm
forces.F:              r2i       = ( x2a(j) - x2ptm * cos(x3b(k) - x3ptm))
forces.F:               prpq      = x1b(i) * sin(x2a(j))
forces.F:               pzpq      = x1b(i) * cos(x2a(j))
forces.F:               r2i       = (-( pzpq - pzpt ) * sin(x2a(j))
forces.F:     2                   * cos(x2a(j))) / ( r2    * sqrt(r2   ) + tiny )
gcollapse.F:         if ( abs(x2a(j)-x20) .lt. abs(x2a(jp1)-x20) ) then
gcollapse.F:     1            + ( x2a(jin (j)) - x20 )**2
gcollapse.F:     1            + ( x2a(jout(j)) - x20 )**2
gcollapse.F:     1            + ( x2a(jin (j)) - x20 )**2
gcollapse.F:     1            + ( x2a(jout(j)) - x20 )**2
gcollapse.F:             rsq  = r**2 * ( 1.0 + drs * sin (m * x2a(j))
gcollapse.F:     1                           + drc * cos (m * x2a(j)) )**2
gcollapse.F:     1                      , x1a(iin (i)), x2a(jin (j)), x3a(kin (k))
gcollapse.F:     2                      , x1a(iout(i)), x2a(jout(j)), x3a(kout(k)) )
ggen.F:c Set up x2a grid lines from j=jmin to jmax, using known values of
ggen.F:       x2a(jmin-joffst) =  x2min
ggen.F:      dx2a(jmin-joffst) = dx2min
ggen.F:        dx2a(j-joffst) = dx2a(j-joffst-1) * x2rat
ggen.F:         x2a(j-joffst) =  x2a(j-joffst-1) + dx2a(j-joffst-1)
ggen.F:        dx2a(js-1) = dx2a(js  )
ggen.F:          dx2a(js-2) = dx2a(js+1)
ggen.F:          dx2min     = dx2a(js+1)
ggen.F:          dx2a(js-2) = dx2a(js-1)
ggen.F:          dx2min     = dx2a(js-2)
ggen.F:        buf_in(1) = dx2a(js  )
ggen.F:        buf_in(2) = dx2a(js+1)
ggen.F:        buf_in(3) = dx2a(js+2)
ggen.F:        dx2a(js-1) = dx2a(je-1)
ggen.F:        dx2a(js-2) = dx2a(je-2)
ggen.F:        dx2min     = dx2a(je-3)
ggen.F:        dx2a(je  ) = dx2a(je-1)
ggen.F:          dx2a(je+1) = dx2a(je-2)
ggen.F:          dx2min     = dx2a(je-3)
ggen.F:          dx2a(je+1) = dx2a(je  )
ggen.F:          dx2a(je+2) = dx2a(je+1)
ggen.F:        buf_in(4) = dx2a(je-1)
ggen.F:        buf_in(5) = dx2a(je-2)
ggen.F:        buf_in(6) = dx2a(je-3)
ggen.F:        dx2a(je  ) = dx2a(js  )
ggen.F:        dx2a(je+1) = dx2a(js+1)
ggen.F:        dx2a(je+2) = dx2a(js+2)
ggen.F:        dx2a(js-1) = buf_out(4)
ggen.F:        dx2a(js-2) = buf_out(5)
ggen.F:        dx2a(je  ) = buf_out(1)
ggen.F:        dx2a(je+1) = buf_out(2)
ggen.F:        dx2a(je+2) = buf_out(3)
ggen.F:      x2a (js-1) = x2a (js  ) - dx2a(js-1)
ggen.F:      x2a (js-2) = x2a (js-1) - dx2a(js-2)
ggen.F:      x2min      = x2a (js-2) - dx2min
ggen.F:      x2a (je+1) = x2a (je  ) + dx2a(je  )
ggen.F:      x2a (je+2) = x2a (je+1) + dx2a(je+1)
ggen.F:      x2max      = x2a (je+2) + dx2a(je+2)
ggen.F:       x2b(js-2) = x2a (js-2) + 0.5 * dx2a(js-2)
ggen.F:         x2b(j) = x2a(j) + 0.5 * dx2a(j)
ggen.F:        vol2a  (j) = x2a(j)
ggen.F:         g32a (j)  = x2a(j)
ggen.F:        vol2a  (j) = x2a(j)**2 / 2.0
ggen.F:         g32a (j)  = sin( x2a(j) )
ggen.F:        dg32ad2(j) = cos( x2a(j) )
ggen.F:        vol2a (j)  =-cos( x2a(j) )
ggen.F:       x2ai  (j) = 1.0 / ( x2a  (j) + tiny )
ggen.F:       dx2ai (j) = 1.0 / ( dx2a (j) + tiny )
ggen.F:         x2ah   (j) = x2a   (j)
ggen.F:         dx2ah  (j) = dx2a  (j)
ggen.F:         x2ahi  (j) = x2ai  (j)
ggen.F:         dx2ahi (j) = dx2ai (j)
ggen.F:         x2an   (j) = x2a   (j)
ggen.F:         dx2an  (j) = dx2a  (j)
ggen.F:         x2ani  (j) = x2ai  (j)
ggen.F:         dx2ani (j) = dx2ai (j)
gpbv.F:C     &                  dx2a(j)*dx3a(k)*d(i,j,k)
gravity.F:         theta1 = x2a(j)
gravity.F:         theta2 = x2a(j+1)
gravity.F:         if(x2a(j+1) .le. halfpi) then
gravity.F:          alpha1 = halfpi - x2a(j)
gravity.F:          alpha2 = halfpi - x2a(j+1)
gravity.F:          alpha1 = onep5pi - x2a(j)
gravity.F:          alpha2 = onep5pi - x2a(j+1)
gravity.F:         theta1 = x2a(j)
gravity.F:         theta2 = x2a(j+1)
grdv.F:     .            + (v2(i  ,j+1,k  ) - v2(i  ,j  ,k  )) * dx2ai(j) 
hsmoc_1D.F:        qv1    = vt(jm1) + dx2a(jm1) * dv (jm1)
hsmoc_1D.F:        qv2    = vt(j  ) - dx2a(j  ) * dv (j  )
hsmoc_1D.F:        qb1    = bt(jm1) + dx2a(jm1) * db (jm1)
hsmoc_1D.F:        qb2    = bt(j  ) - dx2a(j  ) * db (j  )
hsmoc_1D.F:     1              * dx2ah(j) * g2ah(i)
hsmoc_1D.F:     1              * dx2a (j) * g2a (i)
hsmoc_1D.F:           qv1    = vt(jm1) + dx2a(jm1) * dv (jm1)
hsmoc_1D.F:           qv2    = vt(j  ) - dx2a(j  ) * dv (j  )
hsmoc_1D.F:           qb1    = bt(jm1) + dx2a(jm1) * db (jm1)
hsmoc_1D.F:           qb2    = bt(j  ) - dx2a(j  ) * db (j  )
hsmoc_2D.F:             qv1    = vt(j-1) + dx2a(j-1) * dv (j-1)
hsmoc_2D.F:             qv2    = vt(j  ) - dx2a(j  ) * dv (j  )
hsmoc_2D.F:             qb1    = bt(j-1) + dx2a(j-1) * db (j-1)
hsmoc_2D.F:             qb2    = bt(j  ) - dx2a(j  ) * db (j  )
hsmoc_2D.F:             qv1    = vtmp(j-1) + dx2a(j-1) * dv (j-1)
hsmoc_2D.F:             qv2    = vtmp(j  ) - dx2a(j  ) * dv (j  )
hsmoc_2D.F:             qb1    = btmp(j-1) + dx2a(j-1) * db (j-1)
hsmoc_2D.F:             qb2    = btmp(j  ) - dx2a(j  ) * db (j  )
hsmoc_2D.F:     1                   * dx2ah(j) * g2ah(i)
hsmoc_2D.F:     1                   * dx2a (j) * g2a (i)
hsmoc_2D.F:             qv1    = vtmp(j-1) + dx2a(j-1) * dv (j-1)
hsmoc_2D.F:             qv2    = vtmp(j  ) - dx2a(j  ) * dv (j  )
hsmoc_2D.F:             qb1    = btmp(j-1) + dx2a(j-1) * db (j-1)
hsmoc_2D.F:             qb2    = btmp(j  ) - dx2a(j  ) * db (j  )
hsmoc_2D.F:           qv1    = vt(j-1) + dx2a(j-1) * dv (j-1)
hsmoc_2D.F:           qv2    = vt(j  ) - dx2a(j  ) * dv (j  )
hsmoc_2D.F:           qb1    = bt(j-1) + dx2a(j-1) * db (j-1)
hsmoc_2D.F:           qb2    = bt(j  ) - dx2a(j  ) * db (j  )
hsmoc.F:             qv1    = vt(j-1) + dx2a(j-1) * dv (j-1)
hsmoc.F:             qv2    = vt(j  ) - dx2a(j  ) * dv (j  )
hsmoc.F:             qb1    = bt(j-1) + dx2a(j-1) * db (j-1)
hsmoc.F:             qb2    = bt(j  ) - dx2a(j  ) * db (j  )
hsmoc.F:             qv1    = vtmp(j-1) + dx2a(j-1) * dv (j-1)
hsmoc.F:             qv2    = vtmp(j  ) - dx2a(j  ) * dv (j  )
hsmoc.F:             qb1    = btmp(j-1) + dx2a(j-1) * db (j-1)
hsmoc.F:             qb2    = btmp(j  ) - dx2a(j  ) * db (j  )
hsmoc.F:     1                   * dx2ah(j) * g2ah(i)
hsmoc.F:     1                   * dx2a (j) * g2a (i)
hsmoc.F:             qv1    = vtmp(j-1) + dx2a(j-1) * dv (j-1)
hsmoc.F:             qv2    = vtmp(j  ) - dx2a(j  ) * dv (j  )
hsmoc.F:             qb1    = btmp(j-1) + dx2a(j-1) * db (j-1)
hsmoc.F:             qb2    = btmp(j  ) - dx2a(j  ) * db (j  )
hsmoc.F:           qv1    = vt(j-1) + dx2a(j-1) * dv (j-1)
hsmoc.F:           qv2    = vt(j  ) - dx2a(j  ) * dv (j  )
hsmoc.F:           qb1    = bt(j-1) + dx2a(j-1) * db (j-1)
hsmoc.F:           qb2    = bt(j  ) - dx2a(j  ) * db (j  )
icm_initial.F:c         a3(i,j) = prefac*x1a(i)*sin(x2a(j))/(6.0d23) !roughly rout=200 kpc
icm_initial.F:c         b1(i,j,k) = (g32a(j+1)*a3(i,j+1)-g32a(j)*a3(i,j))/(x2a(j+1)-
icm_initial.F:c     &    x2a(j))/g31a(i)/g32b(j)
lorentz_2D.F:             qv1    = vtmp(j-1) + dx2a(j-1) * dv (j-1)
lorentz_2D.F:             qv2    = vtmp(j  ) - dx2a(j  ) * dv (j  )
lorentz_2D.F:             qb1    = btmp(j-1) + dx2a(j-1) * db (j-1)
lorentz_2D.F:             qb2    = btmp(j  ) - dx2a(j  ) * db (j  )
lorentz_2D.F:     4                  * ( bstar(j+1) - bstar(j) ) * dx2ai(j)
lorentz_2D.F:             qv1    = vtmp(j-1) + dx2a(j-1) * dv (j-1)
lorentz_2D.F:             qv2    = vtmp(j  ) - dx2a(j  ) * dv (j  )
lorentz_2D.F:             qb1    = btmp(j-1) + dx2a(j-1) * db (j-1)
lorentz_2D.F:             qb2    = btmp(j  ) - dx2a(j  ) * db (j  )
lorentz_2D.F:     4                  * ( bstar(j+1) - bstar(j) ) * dx2ai(j)
lorentz.F:             qv1    = vtmp(j-1) + dx2a(j-1) * dv (j-1)
lorentz.F:             qv2    = vtmp(j  ) - dx2a(j  ) * dv (j  )
lorentz.F:             qb1    = btmp(j-1) + dx2a(j-1) * db (j-1)
lorentz.F:             qb2    = btmp(j  ) - dx2a(j  ) * db (j  )
lorentz.F:     4                  * ( bstar(j+1) - bstar(j) ) * dx2ai(j)
lorentz.F:             qv1    = vtmp(j-1) + dx2a(j-1) * dv (j-1)
lorentz.F:             qv2    = vtmp(j  ) - dx2a(j  ) * dv (j  )
lorentz.F:             qb1    = btmp(j-1) + dx2a(j-1) * db (j-1)
lorentz.F:             qb2    = btmp(j  ) - dx2a(j  ) * db (j  )
lorentz.F:     4                 * ( bstar(j+1) - bstar(j) ) * dx2ai(j)
mapin.F:      call get_grid_array(x2a,jn,index)
mapin.F:      call get_grid_array(x2ai,jn,index)
mapin.F:      call get_grid_array(dx2a,jn,index)
mapin.F:      call get_grid_array(dx2ai,jn,index)
mapin.F:      call get_grid_array(x2ah,jn,index)
mapin.F:      call get_grid_array(x2an,jn,index)
mapin.F:      call get_grid_array(dx2ah,jn,index)
mapin.F:      call get_grid_array(dx2an,jn,index)
mapin.F:      call get_grid_array(x2ahi,jn,index)
mapin.F:      call get_grid_array(x2ani,jn,index)
mapin.F:      call get_grid_array(dx2ahi,jn,index)
mapin.F:      call get_grid_array(dx2ani,jn,index)
mapout.F:      call put_grid_array(x2a,jn,index)
mapout.F:      call put_grid_array(x2ai,jn,index)
mapout.F:      call put_grid_array(dx2a,jn,index)
mapout.F:      call put_grid_array(dx2ai,jn,index)
mapout.F:      call put_grid_array(x2ah,jn,index)
mapout.F:      call put_grid_array(x2an,jn,index)
mapout.F:      call put_grid_array(dx2ah,jn,index)
mapout.F:      call put_grid_array(dx2an,jn,index)
mapout.F:      call put_grid_array(x2ahi,jn,index)
mapout.F:      call put_grid_array(x2ani,jn,index)
mapout.F:      call put_grid_array(dx2ahi,jn,index)
mapout.F:      call put_grid_array(dx2ani,jn,index)
mhdshktube.F:          if(x2a(j) .le. x20) then
mod_files.F:     .       x1a  , x2a   ,  x3a   ,
mod_files.F:     .       x1ai , x2ai  ,  x3ai  ,
mod_files.F:     .      dx1a  , dx2a  , dx3a   ,
mod_files.F:     .      dx1ai , dx2ai , dx3ai  ,
mod_files.F:     .               x2ah   , x2an   ,
mod_files.F:     .               dx2ah  , dx2an  ,
mod_files.F:     .               x2ahi  , x2ani  ,
mod_files.F:     .               dx2ahi , dx2ani ,
momx2.F:     1                   + ( dx2a(j-1) - xi ) * dq (j-1) )
momx2.F:     3                   - ( dx2a(j  ) + xi ) * dq (j  ) )
momx2.F:             dqm        = (v2 (i  ,j  ,k) - v2 (i  ,j-1,k)) * dx2ai(j-1)
momx2.F:             dqp        = (v2 (i  ,j+1,k) - v2 (i  ,j  ,k)) * dx2ai(j  )
momx2.F:     1                   + ( dx2a(j-1) - xi ) * dq (j-1) )
momx2.F:     3                   - ( dx2a(j  ) + xi ) * dq (j  ) )
momx3.F:         atwidj1(j) = dx2a(j) * dvl2ai(j)
momx3.F:         atwidj3(j) = g32b(j) * dx2a  (j) * dvl2ai(j)
newdt.F:          dr2is      = g2bi (i) * dx2ai(j)
newgrid.F:        call scopy (jn,  x2a n ,1,  x2a ,1)
newgrid.F:        call scopy (jn, dx2a n ,1, dx2a ,1)
newgrid.F:         dx2ai(j) = 1.0/dx2a(j)
newgrid.F:          dg32ad2(j) = cos(x2a(j))
newvg.F:        qb = x2fac*qa/x2a(je)
newvg.F:          vg2(j)=-qb*x2a(j)
newx2.F:      x2an(js-2) = x1an(js-2) + vg2(js-2)*dt
newx2.F:         x2an(j  ) = x2a (j) + vg2(j)*dt
newx2.F:        dx2an(j-1) = x2an(j) - x2an(j-1)
newx2.F:      dx2an(je+2) = (dx2an(je+1)/dx2an(je))*dx2an(je+1)
newx2.F:      dx2bn(js-2) = dx2an(js-2)
newx2.F:       x2bn(js-2) =  x2an(js-1) - 0.5*dx2an(js-2)
newx2.F:         x2bn(j) = x2an(j) + 0.5*dx2an(j)
newx2.F:        g4 a h (j) = 0.5*(x2a(j) + x2an(j))
newx2.F:        g4 a n (j) = x2an(j)
newx2.F:        g32a h (j) =   0.5*(x2a(j) + x2an(j))
newx2.F:        g4 a h (j) = 0.125*(x2a(j) + x2an(j))**2
newx2.F:        g32a n (j) =     x2an(j)
newx2.F:        g4 a n (j) = 0.5*x2an(j)**2
newx2.F:        g32a h (j) =  sin(0.5*(x2a(j) + x2an(j)))
newx2.F:        g4 a h (j) = -cos(0.5*(x2a(j) + x2an(j)))
newx2.F:        g32a n (j) =  sin(x2a n (j))
newx2.F:        g4 a n (j) = -cos(x2a n (j))
qupdate_d.F:        dr2min = min(dx1a(i),g2b(i)*dx2a(j),g31b(i)*g32b(j)*dx3a(k))
qupdate.F:           dTx2 = dTx2*g2ai(i)*dx2ai(j)
qupdate.F:           if (x2a(j).le.1d-10.and.x2a(j).ge.-1d-10) dTx3 = 0.0d0
qupdate.F:           if (x2a(j).le.pi+1d-10.and.x2a(j).ge.pi-1d-10) dTx3 = 0.0d0
qupdate.F:        dTx2 = dTx2*g2bi(i)*dx2ai(j)
qupdate_iso_d.F:        dr2min = min(dx1a(i),g2b(i)*dx2a(j),g31b(i)*g32b(j)*dx3a(k))
radialplot.F:     & *g2ai(i)*dx2ai(j)
radialplot.F:     &   -ecr(i,j-1,k)-ecr(i-1,j-1,k))*g2ai(i)*dx2ai(j)
restart.F:        x2ptm     = x2a(js)
sod.F:          if(x2a(j) .le. x20) then
textdmp.F:      write(12,"('                     x1b             x2a        ',
textdmp.F:      write(12,32) ( ( (i,j,k,x1b(i), x2a(j), x3b(k), v2(i,j,k),
torus.F:        b1(i,j,:) = (g32a(j+1)*A3(i,j+1)-g32a(j)*A3(i,j))/(x2a(j+1)-
torus.F:     &    x2a(j))/g31a(i)/g32b(j)
tranx2.F:     1               + ( dx2a(j-1) - xi ) * dd   (j-1) )
tranx2.F:     3               - ( dx2a(j  ) + xi ) * dd   (j  ) )
tranx2.F:     1                  + (dx2a(j-1) - xi ) * dxo(j-1,n) )
tranx2.F:     3                  - (dx2a(j  ) + xi ) * dxo(j,n  ) )
tranx2.F:     1               + ( dx2a(j-1) - xi ) * deod (j-1) )
tranx2.F:     3               - ( dx2a(j  ) + xi ) * deod (j  ) )
tranx2.F:     1               + ( dx2a(j-1) - xi ) * decrod (j-1) )
tranx2.F:     3               - ( dx2a(j  ) + xi ) * decrod (j  ) )
tranx2.F:     1               + ( dx2a(j-1) - xi ) * dero (j-1) )
tranx2.F:     3               - ( dx2a(j  ) + xi ) * dero (j) )
tranx3.F:       atwid2(j)           = dx2a(j) * dvl2ai(j)
